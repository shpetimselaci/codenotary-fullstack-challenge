/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = {
  '/setup-temp-vault': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Create a temp expirable vault. */
    post: operations['setupTempVault'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collection/{collection}/document': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create new document inside collection
     * @description Create new document inside collection. Source is either JSON from Request Body or a valid json file like myfile.json
     */
    put: operations['documentCreate'];
    /**
     * Replace whole document with new provided
     * @description Replace whole document with new provided. Source is either JSON from Request Body or a valid json file like myfile.json
     */
    post: operations['updateDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documents/{ref}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch a document through its public reference id.
     * @description Fetch a document through its public reference id.
     */
    get: operations['getPublicDocument'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collection/{collection}/documents': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Create multiple documents inside collection
     * @description Create multiple documents inside collection. Source is either from Request Body or a valid file like myfile.json
     */
    put: operations['documentCreateMany'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collection/{collection}/documents/{document}/access-url': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a public access url for a given document.
     * @description Get a public access url for a given document. The document can be accessed publicly with the given url.
     */
    get: operations['accessDocumentUrl'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collection/{collection}/documents/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Search for a document inside collection
     * @description Search a document inside collection. Can be a search without query or with a query. If done without query, will return all documents in the collection.
     */
    post: operations['searchDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collection/{collection}/documents/count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Count documents inside collection
     * @description Return a count of documents inside collection
     */
    post: operations['countDocuments'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collection/{collection}/document/{document-id}/audit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Return diff for document revisions
     * @description Return diff for document revisions for provided document id
     */
    put: operations['diffDocument'];
    /**
     * Return versions of a document
     * @description Return versions of a document
     */
    post: operations['auditDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collection/{collection}/document/{document-id}/proof': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Return a proof for a document
     * @description Return a proof for a document with specified document-id
     */
    post: operations['getDocumentProof'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collection/{collection}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return information about collection
     * @description Return information about a single collection
     */
    get: operations['collectionGet'];
    /**
     * Create collection in the ledger
     * @description Create collection in the ledger
     */
    put: operations['collectionCreate'];
    /**
     * Update collection within the ledger
     * @description Update the primary key label for the  collection within the ledger
     */
    post: operations['collectionUpdate'];
    /**
     * Delete collection
     * @description Delete collection inside ledger
     */
    delete: operations['collectionDelete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return current state of immudb ledger
     * @description Return current state of immudb ledger
     */
    get: operations['getCurrentState'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List collection within a ledger
     * @description List all collections within a ledger
     */
    get: operations['collectionsList'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/collection/{collection}/indexes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Delete index in the collection
     * @description Delete index in the collection and marks that collection field as un-indexed
     */
    put: operations['deleteIndex'];
    /**
     * Create a new index in the collection
     * @description Create a new index in the collection from the previously un-indexed fields that are part of collection schema
     */
    post: operations['createIndex'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/export/s3': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start export request
     * @description Start export request
     */
    post: operations['s3Export'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/export/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return information about export
     * @description Return information about export
     */
    get: operations['getExportInformation'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger/{ledger}/size': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return ledger DB size
     * @description Return ledger DB size
     */
    get: operations['getLedgerDbSize'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
};
export type webhooks = Record<string, never>;
export type components = {
  schemas: {
    ExportID: {
      id: string;
    };
    ExportInformation: {
      id: string;
      message: string;
      /** Format: date-time */
      date: string;
    };
    ExportS3: {
      region: string;
      accessKey: string;
      secretKey: string;
      token: string;
      bucket: string;
      uploadKey: string;
    };
    Collection: {
      /** @example Collection1 */
      name: string;
      /** @example string */
      idFieldName: string;
      fields: Array<components['schemas']['Field']>;
      indexes: Array<components['schemas']['Index']>;
    };
    /** @example {
     *       "field1": "string value",
     *       "field2": 1.3,
     *       "field3": 1,
     *       "field4": true,
     *       "field5": null
     *     } */
    Document: Record<string, never>;
    PaginationRequest: {
      page: number;
      perPage: number;
    };
    PaginationResponse: {
      page: number;
      perPage: number;
    };
    /** @enum {string} */
    StatusCode: 'SUCCESS' | 'UPDATED' | 'INSERTED' | 'ALREADY_EXISTS' | 'ERROR' | 'MISSING_INDEX_KEYS' | 'NOT_FOUND';
    ActionResult: {
      status: components['schemas']['StatusCode'];
      message: string;
      /** @description HTTP status code */
      code?: number;
    };
    ErrReply: {
      /** @description HTTP status code */
      code: number;
      /** @description HTTP status description */
      status: string;
      /** @description Application error message, for debugging */
      error: string;
    };
    Field: {
      name: string;
      type?: components['schemas']['FieldType'];
    };
    /**
     * @default STRING
     * @enum {string}
     */
    FieldType: 'STRING' | 'BOOLEAN' | 'INTEGER' | 'DOUBLE';
    Index: {
      fields: Array<string>;
      isUnique: boolean;
    };
    IndexCreateRequest: {
      fields: Array<string>;
      isUnique: boolean;
    };
    IndexCreateResponse: Record<string, never>;
    IndexDeleteRequest: {
      collection: string;
      fields: Array<string>;
    };
    IndexDeleteResponse: Record<string, never>;
    /** @example {
     *       "field1": "my_object_field1",
     *       "field2": 3,
     *       "field3": 2,
     *       "field4": false
     *     } */
    DocumentInsertRequest: unknown;
    DocumentInsertManyRequest: {
      /** @example [
       *       {
       *         "field1": "some val",
       *         "field2": 123
       *       },
       *       {
       *         "field1": "some other val",
       *         "field2": 12345,
       *         "field3": true
       *       }
       *     ] */
      documents: Array<Record<string, never>>;
    };
    DocumentInsertFromFileRequest: {
      /** Format: binary */
      document: string | Record<string, never>;
    };
    DocumentUpdateFromFileRequest: {
      /** Format: binary */
      document?: string | Record<string, never>;
      query?: components['schemas']['Query'];
    };
    DocumentInsertManyFromFileRequest: {
      /** Format: binary */
      document: string | Record<string, never>;
    };
    DocumentUpdateRequest: {
      document: Record<string, never>;
      query: components['schemas']['Query'];
    };
    /**
     * @default EQ
     * @enum {string}
     */
    Operator: 'EQ' | 'NE' | 'LT' | 'LE' | 'GT' | 'GE' | 'LIKE';
    Query: {
      expressions?: Array<components['schemas']['QueryExpression']>;
      orderBy?: Array<components['schemas']['OrderBy']>;
      limit?: number;
    };
    OrderBy: {
      field: string;
      desc: boolean;
    };
    QueryExpression: {
      fieldComparisons?: Array<components['schemas']['FieldComparison']>;
    };
    FieldComparison: {
      field: string;
      operator: components['schemas']['Operator'];
      value: unknown;
    };
    QueryObject: {
      field: string;
      operator: components['schemas']['Operator'];
      value: string | number;
    };
    DocumentAccessUrlResponse: string;
    DocumentSearchRequest: {
      searchId?: string;
      keepOpen?: boolean;
      query?: components['schemas']['Query'];
    } & components['schemas']['PaginationRequest'];
    DocumentSearchResponse: {
      searchId: string;
      revisions: Array<components['schemas']['DocumentAtRevision']>;
    } & components['schemas']['PaginationResponse'];
    DocumentUpdateResponse: {
      /** Format: uint64 */
      transactionId: string;
      documentId: string;
      /** Format: uint64 */
      revision: string;
    };
    DocumentInsertResponse: {
      /** Format: uint64 */
      transactionId?: string;
      documentId: string;
    };
    DocumentInsertManyResponse: {
      /** Format: uint64 */
      transactionId?: string;
      documentIds: Array<string>;
    };
    DocumentAtRevision: {
      /** Format: uint64 */
      transactionId: string;
      /** Format: uint64 */
      revision: string;
      document: components['schemas']['Document'];
    };
    DocumentDiff: {
      diffIds: string;
      diff: Record<string, never>;
    };
    DocumentAuditRequest: {
      desc: boolean;
    } & components['schemas']['PaginationRequest'];
    DocumentDiffRequest: {
      desc?: boolean;
    } & components['schemas']['PaginationRequest'];
    DocumentProofRequest: {
      transactionId: number;
      proofSinceTransactionId?: number;
    };
    DocumentAuditResponse: {
      revisions: Array<components['schemas']['DocumentAtRevision']>;
    };
    DocumentDiffResponse: {
      revisions: Array<components['schemas']['DocumentAtRevision']>;
      diffs: Array<components['schemas']['DocumentDiff']>;
    };
    DocumentProofResponse: {
      database: string;
      /** Format: int64 */
      collectionId: number;
      idFieldName: string;
      /** Format: byte */
      encodedDocument: string;
      verifiableTx: components['schemas']['schemaVerifiableTxV2'];
    };
    schemaVerifiableTxV2: {
      tx?: components['schemas']['schemaTx'];
      dualProof?: components['schemas']['schemaDualProofV2'];
      signature?: components['schemas']['schemaSignature'];
    };
    /** @description DualProofV2 contains inclusion and consistency proofs */
    schemaDualProofV2: {
      sourceTxHeader?: components['schemas']['schemaTxHeader'];
      targetTxHeader?: components['schemas']['schemaTxHeader'];
      /** @description Inclusion proof of the source transaction hash in the main Merkle Tree */
      inclusionProof?: Array<string>;
      /** @description Consistency proof between Merkle Trees in the source and target transactions */
      consistencyProof?: Array<string>;
    };
    /** @description Transaction header */
    schemaTxHeader: {
      /**
       * Format: uint64
       * @description Transaction ID
       */
      id?: string;
      /**
       * Format: byte
       * @description State value (Accumulative Hash - Alh) of the previous transaction
       */
      prevAlh?: string;
      /**
       * Format: int64
       * @description Unix timestamp of the transaction (in seconds)
       */
      ts?: string;
      /**
       * Format: int32
       * @description Number of entries in a transaction
       */
      nentries?: number;
      /**
       * Format: byte
       * @description Entries Hash - cumulative hash of all entries in the transaction
       */
      eH?: string;
      /**
       * Format: uint64
       * @description Binary linking tree transaction ID
       *     (ID of last transaction already in the main Merkle Tree)
       */
      blTxId?: string;
      /**
       * Format: byte
       * @description Binary linking tree root (Root hash of the Merkle Tree)
       */
      blRoot?: string;
      /**
       * Format: int32
       * @description Header version
       */
      version?: number;
      metadata?: components['schemas']['schemaTxMetadata'];
    };
    /** @description TxMetadata contains metadata set to whole transaction */
    schemaTxMetadata: {
      /**
       * Format: uint64
       * @description Entry expiration information
       */
      truncatedTxID?: string;
    };
    /** @description Transaction to verify */
    schemaTx: {
      header?: components['schemas']['schemaTxHeader'];
      /** @description Raw entry values */
      entries?: Array<components['schemas']['schemaTxEntry']>;
      /** @description KV entries in the transaction (parsed) */
      kvEntries?: Array<components['schemas']['schemaEntry']>;
      /** @description Sorted Set entries in the transaction (parsed) */
      zEntries?: Array<components['schemas']['schemaZEntry']>;
    };
    schemaTxEntry: {
      /**
       * Format: byte
       * @description Raw key value (contains 1-byte prefix for kind of the key)
       */
      key?: string;
      /**
       * Format: byte
       * @description Value hash
       */
      hValue?: string;
      /**
       * Format: int32
       * @description Value length
       */
      vLen?: number;
      metadata?: components['schemas']['schemaKVMetadata'];
      /**
       * Format: byte
       * @description Value, must be ignored when len(value) == 0 and vLen > 0,
       *     otherwise sha256(value) must be equal to hValue
       */
      value?: string;
    };
    schemaZEntry: {
      /**
       * Format: byte
       * @description Name of the sorted set
       */
      set?: string;
      /**
       * Format: byte
       * @description Referenced key
       */
      key?: string;
      entry?: components['schemas']['schemaEntry'];
      /**
       * Format: double
       * @description Sorted set element's score
       */
      score?: number;
      /**
       * Format: uint64
       * @description At which transaction the key is bound
       *     0 if reference is not bound and should read the most recent reference
       */
      atTx?: string;
    };
    schemaEntry: {
      /**
       * Format: uint64
       * @description Transaction id at which the target value was set (i.e. not the reference transaction id)
       */
      tx?: string;
      /**
       * Format: byte
       * @description Key of the target value (i.e. not the reference entry)
       */
      key?: string;
      /**
       * Format: byte
       * @description Value
       */
      value?: string;
      referencedBy?: components['schemas']['schemaReference'];
      metadata?: components['schemas']['schemaKVMetadata'];
      /** @description If set to true, this entry has expired and the value is not retrieved */
      expired?: boolean;
      /**
       * Format: uint64
       * @description Key's revision, in case of GetAt it will be 0
       */
      revision?: string;
    };
    schemaReference: {
      /**
       * Format: uint64
       * @description Transaction if when the reference key was set
       */
      tx?: string;
      /**
       * Format: byte
       * @description Reference key
       */
      key?: string;
      /**
       * Format: uint64
       * @description At which transaction the key is bound, 0 if reference is not bound and should read the most recent reference
       */
      atTx?: string;
      metadata?: components['schemas']['schemaKVMetadata'];
      /**
       * Format: uint64
       * @description Revision of the reference entry
       */
      revision?: string;
    };
    schemaKVMetadata: {
      /** @description True if this entry denotes a logical deletion */
      deleted?: boolean;
      expiration?: components['schemas']['schemaExpiration'];
      /** @description If set to true, this entry will not be indexed and will only be accessed through GetAt calls */
      nonIndexable?: boolean;
    };
    schemaExpiration: {
      /**
       * Format: int64
       * @description Entry expiration time (unix timestamp in seconds)
       */
      expiresAt?: string;
    };
    CollectionUpdateRequest: {
      idFieldName: string;
    };
    CollectionCreateRequest: {
      /** @example string */
      idFieldName?: string;
      fields?: Array<components['schemas']['Field']>;
      indexes?: Array<components['schemas']['Index']>;
    };
    CollectionListResponse: {
      collections: Array<components['schemas']['Collection']>;
    };
    schemaImmutableState: {
      /** @description The db name */
      db?: string;
      /**
       * Format: uint64
       * @description Id of the most recent transaction
       */
      txId?: string;
      /**
       * Format: byte
       * @description State of the most recent transaction
       */
      txHash?: string;
      signature?: components['schemas']['schemaSignature'];
      /**
       * Format: uint64
       * @description Id of the most recent precommitted transaction
       */
      precommittedTxId?: string;
      /**
       * Format: byte
       * @description State of the most recent precommitted transaction
       */
      precommittedTxHash?: string;
    };
    /** @description Signature for the new state value */
    schemaSignature: {
      /** Format: byte */
      publicKey?: string;
      /** Format: byte */
      signature?: string;
    };
    LedgerDBSize: {
      name: string;
      /** Format: double */
      size: number;
    };
    DocumentCountRequest: {
      query?: components['schemas']['Query'];
    };
    DocumentsCountResponse: {
      collection: string;
      count: number;
    };
    SetupTempVaultReply: {
      expiration: string;
      token: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
};
export type $defs = Record<string, never>;
export type operations = {
  setupTempVault: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['SetupTempVaultReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  documentCreate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DocumentInsertRequest'];
        'multipart/form-data': components['schemas']['DocumentInsertFromFileRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentInsertResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Conflict */
      409: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Document too big */
      413: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  updateDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DocumentUpdateRequest'];
        'multipart/form-data': components['schemas']['DocumentUpdateFromFileRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentUpdateResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Document not found */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Conflict */
      409: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Document too big */
      413: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  getPublicDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Public reference id of the supplied document */
        ref: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentAtRevision'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Document not found */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  documentCreateMany: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DocumentInsertManyRequest'];
        'multipart/form-data': components['schemas']['DocumentInsertManyFromFileRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentInsertManyResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Conflict */
      409: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Document too big */
      413: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  accessDocumentUrl: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
        /** @description Document id */
        document: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentAccessUrlResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  searchDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DocumentSearchRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentSearchResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  countDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DocumentCountRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentsCountResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  diffDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
        /** @description Explicit document ID */
        'document-id': string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DocumentDiffRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentDiffResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Document not found */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  auditDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
        /** @description Explicit document ID */
        'document-id': string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DocumentAuditRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentAuditResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Document not found */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  getDocumentProof: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
        /** @description Explicit document ID */
        'document-id': string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DocumentProofRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['DocumentProofResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Document not found */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  collectionGet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['Collection'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Collection not found */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  collectionCreate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CollectionCreateRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content?: never;
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Conflict */
      409: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  collectionUpdate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CollectionUpdateRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content?: never;
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Collection not found */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Conflict */
      409: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  collectionDelete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content?: never;
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Collection not found */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  getCurrentState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['schemaImmutableState'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  collectionsList: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['CollectionListResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  deleteIndex: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['IndexDeleteRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['IndexDeleteResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Index not found */
      404: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  createIndex: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
        /** @description Explicit collection name */
        collection: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['IndexCreateRequest'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['IndexCreateResponse'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Conflict */
      409: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  s3Export: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
      };
      cookie?: never;
    };
    /** @description S3 request */
    requestBody: {
      content: {
        'application/json': components['schemas']['ExportS3'];
      };
    };
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ExportID'];
        };
      };
      /** @description Request validation exception */
      400: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Export request already exists */
      409: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  getExportInformation: {
    parameters: {
      query: {
        /** @description ID of export */
        id: string;
      };
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ExportInformation'];
        };
      };
      /** @description Invalid ID supplied */
      400: {
        headers: Record<string, unknown>;
        content?: never;
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Export request not found */
      404: {
        headers: Record<string, unknown>;
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
  getLedgerDbSize: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Explicit ledger name */
        ledger: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful operation */
      200: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['LedgerDBSize'];
        };
      };
      /** @description Invalid Ledger Name supplied */
      400: {
        headers: Record<string, unknown>;
        content?: never;
      };
      /** @description Payment required */
      402: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Forbidden */
      403: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
      /** @description Export request not found */
      404: {
        headers: Record<string, unknown>;
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: Record<string, unknown>;
        content: {
          'application/json': components['schemas']['ErrReply'];
        };
      };
    };
  };
};
